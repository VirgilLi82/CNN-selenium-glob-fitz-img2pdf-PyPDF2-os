产生一个读取了读取文件结果的array，所有读取文件用的filereader装在array里
（此为执行读取，只有按下回车才算一个线程执行完成，
所以需要指定一个新对象也就是变量承接，即直接在函数中指定array操作无效读取）
function createfilearr(files){
    var abb=[]
    for(var i=0;i<files.length;i++){
        var file=new FileReader()
        abb.push(file)}
    for ( var n in abb){
        abb[n].readAsText(files[n])}
    return abb}

var jieguo=createfilearr(put.files)

从读取文件结果的装满filereader的array（作为函数的参数readobject），
变为产生关于同一个output（数字1，2等的）tensor数组方法：
function crearetensor(readobject,numoftennsorsize){
    var shuzu=[]
    for (var g=0;g<readobject.length;g++){
        shuzu.push(tf.tensor(readobject[g].onload=creareArray(numoftennsorsize,readobject[g].result)))}
    return shuzu
}

适用所有位数数字的方法（把字符结果变为JS数字的方法，有了JS数字才能变为tensor，number即为想建立array的size）
function creareArray(number,jieguo){
    var arr=[] 
    var ray=[]
    var newres=jieguo.split(',')
for(var i=0;i<=newres.length;i++){
    var num=Number(newres[i])
    arr.push(num)
    if(arr.length==number){
        ray.push(arr)
        arr=[]}}
    return ray}


产生input方法
function creareinput(num,Jspath){
    for (var i=0;i<num;i++){
        var put=document.createElement('input')
        put.type='file'
        put.id=String(i)
	put.accept='.txt'
	put.multiple=true
        Jspath.append(put)}}



var model=tf.sequential()
undefined
model.add(tf.layers.conv1d({inputShape:[25,25],kernelSize:1,filters:2,strides:1,activation:'relu',kernelInitializer:'VarianceScaling'}))
undefined
model.add(tf.layers.maxPool1d({kernelsize:2,strides:2}))
undefined
model.add(tf.layers.conv1d({kernelSize:2,filters:3,strides:2,activation:'relu',kernelInitializer:'VarianceScaling'}))
undefined
model.add(tf.layers.flatten())
undefined
model.add(tf.layers.dense({units:10,kernelInitializer:'VarianceScaling'}))



#创建[6,25,25]tensor
tenarr=[]
for (var i=0;i<xinarr[0].length;i++){
    tenarr.push(creareArray(25,xinarr[0][i].result))}


#产生output结果的数组模式，每一个label含有的batchsize都能设定
function creareresultarr(numberoflabel,batchsize){
    var finalarr=[]
    var newresultarr=[]
    for (var g=0;g<numberoflabel;g++){
        var myarr=Array(numberoflabel)
        myarr.fill(0)
        myarr[g]=1
        for (var x=0;x<batchsize;x++){
            finalarr.push(myarr)}
        newresultarr.push(tf.tensor(finalarr))
        finalarr=[]}
    return newresultarr}